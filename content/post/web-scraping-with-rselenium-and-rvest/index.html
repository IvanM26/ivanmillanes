---
title: Webscraping with RSelenium and rvest
author: Ivan Millanes
date: '2020-06-30'
slug: webscraping-with-rselenium-and-rvest
categories: []
tags:
  - R
  - rvest
  - RSelenium
  - tidyverse
  - parallel
  - webscraping
subtitle: ''
summary: "In this post I show how to scrape Dynamic Web Pages using RSelenium and rvest."
authors: []
lastmod: '2020-06-30T19:22:14-03:00'
featured: no
image:
  caption: ''
  focal_point: ''
  preview_only: no
projects: []
---



<div id="key-concepts" class="section level1">
<h1>Key concepts</h1>
<div id="static-vs-dynamic-web-pages" class="section level2">
<h2>Static vs Dynamic Web Pages</h2>
<p>Let’s compare the following websites:
- <a href="https://www.imdb.com/">IMDb (Internet Movie Database)</a>
- <a href="https://www.premierleague.com/stats/top/players/goals">Premier League Stats</a></p>
<p>On <a href="https://www.imdb.com/">IMDb</a>, if you search for a particular movie (for example, <a href="https://www.imdb.com/title/tt0468569/">this one</a>), you can see that the URL changes, and that URL is different from any other movie (for example, <a href="https://www.imdb.com/title/tt2397535/">this one</a>). The same behavior is shown if you search for different actors.</p>
<p>On the other hand, if you go to <a href="https://www.premierleague.com/stats/top/players/goals">Premier League Player Stats</a>, you will notice that modifying the filters or clicking the pagination button to access more data doesn’t produce changes on the URL.</p>
<p>As I understand it, the first website is an example of a <strong>static</strong> web page, while the second one is an example of a <strong>dynamic</strong> webpage.</p>
<p>The following definitions where taken from <a href="https://www.pcmag.com/" class="uri">https://www.pcmag.com/</a>.</p>
<ul>
<li><p><a href="https://www.pcmag.com/encyclopedia/term/static-web-page">Static Web Page</a>: A Web page (HTML page) that contains the same information for all users. Although it may be periodically updated from time to time, it does not change with each user retrieval.</p></li>
<li><p><a href="https://www.pcmag.com/encyclopedia/term/dynamic-web-page">Dynamic Web Page</a>: A Web page that provides custom content for the user based on the results of a search or some other request. Also known as “dynamic HTML” or “dynamic content”, the “dynamic” term is used when referring to interactive Web pages created for each user.</p></li>
</ul>
</div>
</div>
<div id="load-packages" class="section level1">
<h1>Load Packages</h1>
<p>The following packages need to be installed and loaded in order to run the code written in this post.</p>
<pre class="r"><code>library(tidyverse)
library(rvest)
library(RSelenium)</code></pre>
</div>
<div id="start-selenium" class="section level1">
<h1>Start Selenium</h1>
<p>Starting a Selenium server and browser is pretty straightforward using <a href="https://www.rdocumentation.org/packages/RSelenium/versions/1.7.7/topics/rsDriver"><code>rsDriver()</code></a>. The parameter <code>chromever</code> defined this way always uses the latest compatible ChromeDriver version (the code was extracted from <a href="https://stackoverflow.com/questions/55201226/session-not-created-this-version-of-chromedriver-only-supports-chrome-version-7/56173984#56173984">this</a> StackOverflow post).</p>
<pre class="r"><code># Start Selenium server and browser
rD &lt;- RSelenium::rsDriver(
  browser = &quot;chrome&quot;,
  chromever = system2(
    command = &quot;wmic&quot;,
    args = &#39;datafile where name=&quot;C:\\\\Program Files (x86)\\\\Google\\\\Chrome\\\\Application\\\\chrome.exe&quot; get Version /value&#39;,
    stdout = TRUE,
    stderr = TRUE) %&gt;%
    stringr::str_extract(pattern = &quot;(?&lt;=Version=)\\d+\\.\\d+\\.\\d+\\.&quot;) %&gt;%
    magrittr::extract(!is.na(.)) %&gt;%
    stringr::str_replace_all(pattern = &quot;\\.&quot;, replacement = &quot;\\\\.&quot;) %&gt;%
    paste0(&quot;^&quot;,  .) %&gt;%
    stringr::str_subset(string = binman::list_versions(appname = &quot;chromedriver&quot;) %&gt;%
                          dplyr::last()) %&gt;%
    as.numeric_version() %&gt;%
    max() %&gt;%
    as.character()
  )

# Assign the client to an object
remDr &lt;- rD[[&quot;client&quot;]]</code></pre>
<p>After you run <code>rD &lt;- RSelenium::rsDriver(...)</code>, if everything worked correctly, a new chrome window will open. This window should look like this:</p>
<p><img src="/img/rselenium-rvest/01.PNG" style="width:100.0%;height:100.0%" /></p>
<p>You can find more information about <code>rsDriver()</code> in the <a href="https://docs.ropensci.org/RSelenium/articles/basics.html#rsdriver-1">Basics Vignette</a>.</p>
</div>
<div id="basic-usage" class="section level1">
<h1>Basic Usage</h1>
<p>In this section I’ll apply different methods to the <code>remDr</code> object created above. I’m only going to describe the methods that I think will be used most frequently. For a complete reference, check the <a href="https://cran.r-project.org/web/packages/RSelenium/RSelenium.pdf">package documentation</a>.</p>
<ul>
<li><code>navigate(url)</code>: Navigate to a given url.</li>
</ul>
<pre class="r"><code>remDr$navigate(&quot;https://www.google.com/&quot;)
remDr$navigate(&quot;https://www.nytimes.com/&quot;)

# Use method without () to get a description of what it does
remDr$navigate</code></pre>
<ul>
<li><code>goBack()</code>: Equivalent to hitting the back button on the browser.</li>
<li><code>goForward()</code>: Equivalent to hitting the forward button on the browser.</li>
</ul>
<pre class="r"><code>remDr$goBack()
remDr$goForward()</code></pre>
<ul>
<li><code>refresh()</code>: Reload the current page.</li>
</ul>
<pre class="r"><code>remDr$refresh()</code></pre>
<ul>
<li><code>getCurrentUrl()</code>: Retrieve the url of the current page.</li>
</ul>
<pre class="r"><code>remDr$getCurrentUrl()</code></pre>
<ul>
<li><code>maxWindowSize()</code>: Set the size of the browser window to maximum. By default, the browser window size is small, and some elements of the website you navigate to might not be available right away (I’ll talk more about this in the next section).</li>
</ul>
<pre class="r"><code>remDr$maxWindowSize()</code></pre>
<ul>
<li><code>getPageSource()[[1]]</code> Get the current page source. This method combined with <code>rvest</code> is what makes possible to scrape dynamic web pages. The xml document returned by the method can then be read using <code>rvest::read_html()</code>. This method returns a <code>list</code> object, that’s the reason behind <code>[[1]]</code>.</li>
</ul>
<pre class="r"><code>remDr$getPageSource()[[1]]</code></pre>
<ul>
<li><code>open(silent = FALSE)</code>: Send a request to the remote server to instantiate the browser. I use this method when the browser closes for some reason (for example, inactivity). If you have already started the Selenium server, you should run this instead of <code>rD &lt;- RSelenium::rsDriver(...)</code> to re-open the browser.</li>
</ul>
<pre class="r"><code>remDr$open()</code></pre>
<ul>
<li><code>close()</code>: Close the current session.</li>
</ul>
<pre class="r"><code>remDr$close()</code></pre>
<div id="working-with-elements" class="section level2">
<h2>Working with Elements</h2>
<ul>
<li><p><code>findElement(using, value)</code>. Search for an element on the page, starting from the document root. The located element will be returned as an object of webElement class. To use this function you need some basic knowledge of HTML and CSS (or xpath, etc). <a href="https://chrome.google.com/webstore/detail/selectorgadget/mhjhnkcfbdhnjickkkdbjoemdmbfginb?hl=es">This</a> chrome extension, called SelectorGadget, might help.</p></li>
<li><p><code>highlightElement()</code>: Utility function to highlight current Element. This helps to check that you selected the wanted element.</p></li>
<li><p><code>sendKeysToElement()</code>: Send a sequence of key strokes to an element. The key strokes are sent as a list. Plain text is enter as an unnamed element of the list. Keyboard entries are defined in <a href="https://github.com/SeleniumHQ/selenium/wiki/JsonWireProtocol#sessionsessionidelementidvalue">‘selKeys‘</a> and should be listed with name ‘key‘.</p></li>
<li><p><code>clearElement()</code>: Clear a TEXTAREA or text INPUT element’s value.</p></li>
<li><p><code>clickElement()</code>: Click the element. You can click links, check boxes, dropdown lists, etc.</p></li>
</ul>
<pre class="r"><code># Navigate to Google
remDr$navigate(&quot;https://www.google.com/&quot;)

# Find search box
webElem &lt;- remDr$findElement(using = &quot;css selector&quot;, value = &quot;.gLFyf.gsfi&quot;)

# Highlight to check that was correctly selected
webElem$highlightElement()

# Send search and press enter
# Option 1
webElem$sendKeysToElement(list(&quot;the new york times&quot;))
webElem$sendKeysToElement(list(key = &quot;enter&quot;))
# Option 2
webElem$sendKeysToElement(list(&quot;the new york times&quot;, key = &quot;enter&quot;))

# Go back to Google
remDr$goBack()

# Search something else
webElem$sendKeysToElement(list(&quot;finantial times&quot;))

# Clear element
webElem$clearElement()

# Search and click
webElem &lt;- remDr$findElement(using = &quot;css selector&quot;, value = &quot;.gLFyf.gsfi&quot;)
webElem$sendKeysToElement(list(&quot;the new york times&quot;, key = &quot;enter&quot;))
webElem &lt;- remDr$findElement(using = &quot;css selector&quot;, value = &quot;.LC20lb.DKV0Md&quot;)
webElem$clickElement()</code></pre>
</div>
<div id="other-methods" class="section level2">
<h2>Other Methods</h2>
<p>Even though I have never used them, I believe this methods are worth mentioning. For more information, check the <a href="https://cran.r-project.org/web/packages/RSelenium/RSelenium.pdf">package documentation</a>.</p>
<pre class="r"><code>remDr$getStatus()
remDr$getTitle()

remDr$screenshot()

remDr$getWindowSize()
remDr$setWindowSize(1000,800)
remDr$getWindowPosition()
remDr$setWindowPosition(100, 100)

webElem$getElementLocation()</code></pre>
</div>
</div>
<div id="example-webscraping-premier-league-player-stats" class="section level1">
<h1>Example: Webscraping Premier League Player Stats</h1>
<p>In this example, I’ll scrape data from <a href="https://www.premierleague.com/stats/top/players/goals">Premier League Player Stats</a>. This is what the website looks like:</p>
<p><img src="/img/rselenium-rvest/02.PNG" /></p>
<p>You will notice that when you modify the <strong>Filters</strong>, the URL does not change. So you can’t use <code>rvest</code> alone to dynamically scrape this website. Also, if you scroll down to the end of the table you’ll see that there are pagination buttons. If you click them, you get more data, but again, the URL does not change. Here you can see how those pagination buttons look like:</p>
<p><img src="/img/rselenium-rvest/03.PNG" /></p>
<p><strong>Observation</strong>: Even though choosing a different stat <em>does</em> change the URL, I’ll work as if it didn’t.</p>
<div id="target-dataset" class="section level2">
<h2>Target Dataset</h2>
<p>The dataset I want will have the following variables:</p>
<ul>
<li><strong>Player</strong>: Indicates the player name.</li>
<li><strong>Nationality</strong>: Indicates the nationality of the player.</li>
<li><strong>Season</strong>: Indicates the season the stats corresponds to.</li>
<li><strong>Club</strong>: Indicates the club the player belonged to in the season.</li>
<li><strong>Position</strong>: Indicates the player position in the season.</li>
<li><strong>Stats</strong>: One column for each Stat.</li>
</ul>
<p>For simplicity, I’ll scrape data from seasons 2017/18 and 2018/19, and only from the <strong>Goals</strong>, <strong>Assists</strong>, <strong>Minutes Played</strong>, <strong>Passes</strong>, <strong>Shots</strong> and <strong>Fouls</strong> stats. This means that our dataset will have a total of 11 columns.</p>
</div>
<div id="before-we-start" class="section level2">
<h2>Before we start…</h2>
<p>In order to run the code below, you have to start a Selenium server and browser, and create the <code>remDr</code> object. This procedure was described in the <a href="#start-selenium">Start Selenium</a> section.</p>
</div>
<div id="first-steps" class="section level2">
<h2>First Steps</h2>
<p>The code chunk below navigates to the website, increases the windows size to find elements that might be hidden (for example, when the window is small I can’t see the <strong>Filters</strong>) and then clicks the “Accept Cookies” button.</p>
<p>You might notice two things:</p>
<ul>
<li><p>The use of the <code>Sys.sleep()</code> function. Here, this function is used to give the website enough time to load. Sometimes, if the element you want to find isn’t loaded when you search for it, it will produce an error.</p></li>
<li><p>The use of CSS selectors. To select an element using CSS you can press F12 an inspect the page source (right clicking the element and selecting <strong>Inspect</strong> will show you which part of that code refers to the element) and/or use <a href="https://chrome.google.com/webstore/detail/selectorgadget/mhjhnkcfbdhnjickkkdbjoemdmbfginb?hl=es">this</a> chrome extension, called SelectorGadget. I recommend learning a little about HTML and CSS and use this two approaches simultaneosly. SelectorGadget helps, but sometimes you will need to inspect the source to get exactly what you want. In the next subsection I’ll show how I selected certain elements by inspecting the page source.</p></li>
</ul>
<pre class="r"><code># Navigate to the website
remDr$navigate(&quot;https://www.premierleague.com/stats/top/players/goals?se=274&quot;)
# Give some time to load
Sys.sleep(4)

# Increase window size to find elements
remDr$maxWindowSize()

# Accept cookies
acceptCookies &lt;- remDr$findElement(using = &quot;css selector&quot;,
                                   value = &quot;div[class=&#39;btn-primary cookies-notice-accept&#39;]&quot;)
acceptCookies$clickElement()</code></pre>
</div>
<div id="getting-values-to-iterate-over" class="section level2">
<h2>Getting Values to Iterate Over</h2>
<p>I know that in order to get the data, I’ll have to iterate over different lists of values. In particular, I need a list of stats, seasons, and player positions.</p>
<p>We can use <code>rvest</code> to scrape the website and get these lists. To do so, we need to find the corresponding nodes. As an example, after the code I’ll show where I searched for the required information in the page source for the stats and seasons lists.</p>
<p>The code below uses <code>rvest</code>to create the lists we’ll use in the loops.</p>
<pre class="r"><code># Read page source
source &lt;- remDr$getPageSource()[[1]]

# Get topStats
list_topStats &lt;- read_html(source) %&gt;% 
  html_nodes(&quot;.topStatsLink&quot;) %&gt;% 
  html_text() %&gt;% 
  str_trim() %&gt;% 
  str_to_title() # Observation below.

# To make example simple
list_topStats &lt;- list_topStats[c(1, 2, 5, 8, 10, 15)]

# Get seasons
list_seasons &lt;- read_html(source) %&gt;% 
  html_nodes(&quot;ul[data-dropdown-list=FOOTBALL_COMPSEASON] &gt; li&quot;) %&gt;% 
  html_attr(&quot;data-option-name&quot;) %&gt;% 
  .[-1] # Remove &quot;All seasons&quot; option

# To make example simple
list_seasons &lt;- list_seasons[c(2,3)]

# Get positions
list_positions &lt;- read_html(source) %&gt;% 
  html_nodes(&quot;ul[data-dropdown-list=Position] &gt; li&quot;) %&gt;% 
  html_attr(&quot;data-option-id&quot;) %&gt;% 
  .[-1] # Remove &quot;All positions&quot; option</code></pre>
<p><strong>Observation</strong>: Even though in the source we don’t see that each word has its first letter
uppercased, when we check the dropdown list we see exactly that (for example, we have “Clean Sheets” instead of “Clean sheets”). I was getting an error when trying to scrape these type of stats, and making them look like the dropdown list solved the issue. That’s the reason behind <code>str_to_title()</code>.</p>
<div id="stats" class="section level3">
<h3>Stats</h3>
<p>This is my view when I open the stats dropdown list and right click and inspect the Clean Sheets stat.</p>
<p><img src="/img/rselenium-rvest/04.PNG" /></p>
<p>Taking a closer look to the source where that element is present we get:</p>
<p><img src="/img/rselenium-rvest/05.PNG" /></p>
</div>
<div id="seasons" class="section level3">
<h3>Seasons</h3>
<p>This is my view when I open the seasons dropdown list and right click and inspect the 2016/17 season.</p>
<p><img src="/img/rselenium-rvest/06.PNG" /></p>
<p>Taking a closer look to the source where that element is present we get:</p>
<p><img src="/img/rselenium-rvest/07.PNG" /></p>
<p>As you can see, we have an attribute named <code>data-dropdown-list</code> whose value is <code>FOOTBALL_COMPSEASON</code> and inside we have <code>li</code> tags where the attribute <code>data-option-name</code> changes for each season. This will be useful when defining how to iterate using <code>RSelenium</code>.</p>
</div>
<div id="positions" class="section level3">
<h3>Positions</h3>
<p>The logic behind getting the CSS for the positions is similar to the one described above, so I won’t be showing it.</p>
</div>
</div>
<div id="webscraping-loop" class="section level2">
<h2>Webscraping Loop</h2>
<p>The code has comments on each step, so you can check it out! But before that, I’ll give an overview of the loop.</p>
<ol style="list-style-type: decimal">
<li><p>Preallocate stats vector. This list will have a length equal to the number of stats to be scraped.</p></li>
<li><p>For each stat:</p>
<ol style="list-style-type: decimal">
<li>Click the stat dropdown list</li>
<li>Click the corresponding stat</li>
<li>Preallocate seasons vector. This list will have a length equal to the number of seasons to be scraped.</li>
<li>For each season inside stat:
<ol style="list-style-type: decimal">
<li>Click the seasons dropdown list</li>
<li>Click the corresponding season</li>
<li>Preallocate positions vector. This list will have <code>length = 4</code> (positions are fixed: GOALKEEPER, DEFENDER, MIDFIELDER and FORWARD).</li>
<li>For each position inside season inside stat
<ol style="list-style-type: decimal">
<li>Click the position dropdown list</li>
<li>Click the corresponding position</li>
<li>Check that there is a table with data (if not, go to next position)</li>
<li>Scrape the first table</li>
<li>While “Next Page” button exists
<ol style="list-style-type: decimal">
<li>Click “Next Page” button</li>
<li>Scrape new table</li>
<li>Append new table to table</li>
</ol></li>
<li>Change stat colname and add position data</li>
<li>Go to the top of the website</li>
</ol></li>
<li>Rowbind each position table</li>
<li>Add season data</li>
</ol></li>
<li>Rowbind each season table</li>
<li>Assign the table to the corresponding stat element.</li>
</ol></li>
</ol>
<p>The result of this loop is a populated <code>list</code> with a number of elements equal to the number of stats scraped. Each of this elements is a <code>tibble</code>.</p>
<p>This may take some time to run, so you can choose less stats to try it out.</p>
<p>As I mentioned, you can check the code!</p>
<pre class="r"><code># Preallocate vector
data_topStats &lt;- vector(&quot;list&quot;, length(list_topStats))

# Iterate over topStat
for (i in seq_along(list_topStats)){
  # Open topStat dropdown list
  DDLtopStat &lt;- remDr$findElement(using = &quot;css selector&quot;, 
                    value = &quot;.dropDown.noLabel.topStatsFilterDropdown&quot;)
  DDLtopStat$clickElement()
  Sys.sleep(2)
  
  # Click corresponding topStat
  ELEMtopStat &lt;- remDr$findElement(using = &quot;link text&quot;, 
                                   value = list_topStats[[i]])
  ELEMtopStat$clickElement()
  Sys.sleep(2)
  
  # Preallocate vector
  data_seasons &lt;- vector(&quot;list&quot;, length(list_seasons))
  
  # Iterate over seasons
  for (j in seq_along(list_seasons)){
    # Open seasons dropdown list
    DDLseason &lt;- remDr$findElement(using = &quot;css selector&quot;, 
                                   value = &quot;.current[data-dropdown-current=FOOTBALL_COMPSEASON]&quot;)
    DDLseason$clickElement()
    Sys.sleep(2)
    
    # Click corresponding season
    ELEMseason &lt;- remDr$findElement(using = &quot;css selector&quot;,
                                    value = str_c(&quot;ul[data-dropdown-list=FOOTBALL_COMPSEASON] &gt; li[data-option-name=&#39;&quot;, list_seasons[[j]], &quot;&#39;]&quot;))
    ELEMseason$clickElement()
    Sys.sleep(2)
    
    # Preallocate vector
    data_positions &lt;- vector(&quot;list&quot;, length(list_positions))
    
    # Iterate over position
    for (k in seq_along(list_positions)){
      # Open positions dropdown list
      DDLposition &lt;- remDr$findElement(using = &quot;css selector&quot;, 
                                       value = &quot;.current[data-dropdown-current=Position]&quot;)
      DDLposition$clickElement()
      Sys.sleep(2)
      
      # Click corresponding position
      ELEMposition &lt;- remDr$findElement(using = &quot;css selector&quot;, 
                                        value = str_c(&quot;ul[data-dropdown-list=Position] &gt; li[data-option-id=&#39;&quot;, list_positions[[k]], &quot;&#39;]&quot;))
      ELEMposition$clickElement()
      Sys.sleep(2)
      
      # Check that there is a table to scrape. If there isn&#39;t, go to next position
      check_table &lt;- remDr$getPageSource()[[1]] %&gt;% 
        read_html() %&gt;% 
        html_node(&quot;.statsTableContainer&quot;) %&gt;% 
        html_text()
      
      if(check_table == &quot;No stats are available for your search&quot;) next
      
      # Populate element of corresponding position (first page)
      data_positions[[k]] &lt;- remDr$getPageSource()[[1]] %&gt;% 
        read_html() %&gt;% 
        html_table() %&gt;% 
        .[[1]] %&gt;% 
        as_tibble() %&gt;% 
        # Thousands are character (&quot;1,000&quot;), problem when binding with integer (1:999)
        mutate(Stat = as.character(Stat) %&gt;% 
                 parse_number())
      
      # Get tables from every page
      btnNextExists &lt;- remDr$getPageSource()[[1]] %&gt;% 
        read_html() %&gt;% 
        html_node(&quot;.paginationNextContainer.inactive&quot;) %&gt;% 
        html_text() %&gt;% 
        is.na()
      
      # While there is a Next button to click
      while (btnNextExists){
        # Click &quot;Next&quot;
        btnNext &lt;- remDr$findElement(using = &quot;css selector&quot;,
                                     value = &quot;.paginationNextContainer&quot;)
        btnNext$clickElement()
        Sys.sleep(2)
        
        # Get table from new page
        table_n &lt;- remDr$getPageSource()[[1]] %&gt;% 
          read_html() %&gt;% 
          html_table() %&gt;% 
          .[[1]] %&gt;% 
          as_tibble() %&gt;% 
          mutate(Stat = as.character(Stat) %&gt;% 
                   parse_number())  
        
        #Rowbind existing table and new table
        data_positions[[k]] &lt;- bind_rows(data_positions[[k]], table_n)
        
        # Update Check for Next Button
        btnNextExists &lt;- remDr$getPageSource()[[1]] %&gt;% 
          read_html() %&gt;% 
          html_node(&quot;.paginationNextContainer.inactive&quot;) %&gt;% 
          html_text() %&gt;% 
          is.na()
        
        Sys.sleep(1)
      }
      
      # Data wrangling
      data_positions[[k]] &lt;- data_positions[[k]] %&gt;% 
        rename(!!list_topStats[[i]] := Stat) %&gt;% 
        mutate(Position = list_positions[[k]])
      
      # Go to top of the page to select next position
      goTop &lt;- remDr$findElement(&quot;css&quot;, &quot;body&quot;)
      goTop$sendKeysToElement(list(key = &quot;home&quot;))
      Sys.sleep(3)
    }
    
    # Rowbind positions dataset
    data_positions &lt;- reduce(data_positions, bind_rows)
    
    # Populate corresponding season
    data_seasons[[j]] &lt;- data_positions %&gt;% 
      mutate(Season = list_seasons[[j]])
    
  }
  
  # Rowbind seasons dataset
  data_seasons &lt;- reduce(data_seasons, bind_rows)
  
  # Populate corresponding topStat
  data_topStats[[i]] &lt;- data_seasons
    
}</code></pre>
<p><strong>Observation</strong>: Be careful when you add more stats to the loop. For example, Clean Sheets has the Position filter hidden, so the code should be modified (for example, by adding some “if” statement).</p>
</div>
<div id="data-wrangling" class="section level2">
<h2>Data Wrangling</h2>
<p>Finally, some data wrangling is needed to create our dataset. <code>data_topStats</code> is a <code>list</code> with 6 elements, each one of those elements is a <code>tibble</code>. The next code chunk removes the <code>Rank</code> column from each <code>tibble</code>, reorders the columns and then makes a full join by all the non-stat variables using <code>reduce()</code> (the reason behind this full join is that not all players have all stats). In the last line of code I replace <code>NA</code> values with zero in the stats variables.</p>
<pre class="r"><code>dataset &lt;- data_topStats %&gt;% 
  # Remove Rank column
  map(function(x) select(x, -Rank)) %&gt;% 
  # Reorder columns
  map(function(x) select(x, Season, Position, Club, Player, Nationality, everything())) %&gt;%
  # Full join (because not necessarily all players have all stats)
  reduce(full_join, by = c(&quot;Season&quot;, &quot;Position&quot;, &quot;Club&quot;, &quot;Player&quot;, &quot;Nationality&quot;)) %&gt;% 
  # Replace NA with 0 in numeric columns
  mutate(across(where(is.numeric), replace_na, replace = 0))</code></pre>
<p>This is how the data looks like.</p>
<pre class="r"><code>dataset %&gt;%
  head %&gt;%
  knitr::kable(format = &quot;html&quot;, table.attr = &quot;style = \&quot;color: white;\&quot;&quot;)</code></pre>
<table style = "color: white;">
<thead>
<tr>
<th style="text-align:left;">
Season
</th>
<th style="text-align:left;">
Position
</th>
<th style="text-align:left;">
Club
</th>
<th style="text-align:left;">
Player
</th>
<th style="text-align:left;">
Nationality
</th>
<th style="text-align:right;">
Goals
</th>
<th style="text-align:right;">
Assists
</th>
<th style="text-align:right;">
Minutes Played
</th>
<th style="text-align:right;">
Passes
</th>
<th style="text-align:right;">
Shots
</th>
<th style="text-align:right;">
Fouls
</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left;">
2018/19
</td>
<td style="text-align:left;">
DEFENDER
</td>
<td style="text-align:left;">
Brighton and Hove Albion
</td>
<td style="text-align:left;">
Shane Duffy
</td>
<td style="text-align:left;">
Ireland
</td>
<td style="text-align:right;">
5
</td>
<td style="text-align:right;">
1
</td>
<td style="text-align:right;">
3088
</td>
<td style="text-align:right;">
1305
</td>
<td style="text-align:right;">
37
</td>
<td style="text-align:right;">
22
</td>
</tr>
<tr>
<td style="text-align:left;">
2018/19
</td>
<td style="text-align:left;">
DEFENDER
</td>
<td style="text-align:left;">
AFC Bournemouth
</td>
<td style="text-align:left;">
Nathan Aké
</td>
<td style="text-align:left;">
Netherlands
</td>
<td style="text-align:right;">
4
</td>
<td style="text-align:right;">
0
</td>
<td style="text-align:right;">
3412
</td>
<td style="text-align:right;">
1696
</td>
<td style="text-align:right;">
25
</td>
<td style="text-align:right;">
28
</td>
</tr>
<tr>
<td style="text-align:left;">
2018/19
</td>
<td style="text-align:left;">
DEFENDER
</td>
<td style="text-align:left;">
Cardiff City
</td>
<td style="text-align:left;">
Sol Bamba
</td>
<td style="text-align:left;">
Cote D’Ivoire
</td>
<td style="text-align:right;">
4
</td>
<td style="text-align:right;">
1
</td>
<td style="text-align:right;">
2475
</td>
<td style="text-align:right;">
550
</td>
<td style="text-align:right;">
22
</td>
<td style="text-align:right;">
35
</td>
</tr>
<tr>
<td style="text-align:left;">
2018/19
</td>
<td style="text-align:left;">
DEFENDER
</td>
<td style="text-align:left;">
Wolverhampton Wanderers
</td>
<td style="text-align:left;">
Willy Boly
</td>
<td style="text-align:left;">
France
</td>
<td style="text-align:right;">
4
</td>
<td style="text-align:right;">
0
</td>
<td style="text-align:right;">
3168
</td>
<td style="text-align:right;">
1715
</td>
<td style="text-align:right;">
24
</td>
<td style="text-align:right;">
29
</td>
</tr>
<tr>
<td style="text-align:left;">
2018/19
</td>
<td style="text-align:left;">
DEFENDER
</td>
<td style="text-align:left;">
Everton
</td>
<td style="text-align:left;">
Lucas Digne
</td>
<td style="text-align:left;">
France
</td>
<td style="text-align:right;">
4
</td>
<td style="text-align:right;">
4
</td>
<td style="text-align:right;">
2966
</td>
<td style="text-align:right;">
1457
</td>
<td style="text-align:right;">
34
</td>
<td style="text-align:right;">
39
</td>
</tr>
<tr>
<td style="text-align:left;">
2018/19
</td>
<td style="text-align:left;">
DEFENDER
</td>
<td style="text-align:left;">
Wolverhampton Wanderers
</td>
<td style="text-align:left;">
Matt Doherty
</td>
<td style="text-align:left;">
Ireland
</td>
<td style="text-align:right;">
4
</td>
<td style="text-align:right;">
5
</td>
<td style="text-align:right;">
3147
</td>
<td style="text-align:right;">
1399
</td>
<td style="text-align:right;">
46
</td>
<td style="text-align:right;">
30
</td>
</tr>
</tbody>
</table>
</div>
</div>
<div id="parallel-framework" class="section level1">
<h1>parallel Framework</h1>
<p>The framework described here is an approach to working in <code>parallel</code> with <code>RSelenium</code>.</p>
<p>First, we load the libraries we need.</p>
<pre class="r"><code># Load libraries
library(tidyverse)
library(parallel)</code></pre>
<p>The function defined below stops Selenium on each core.</p>
<pre class="r"><code># Define function to stop Selenium on each core
close_rselenium &lt;- function(){
  clusterEvalQ(clust, {
    remDr$close()
    rD$server$stop()
  })
  system(&quot;taskkill /im java.exe /f&quot;, intern=FALSE, ignore.stdout=FALSE)
}</code></pre>
<p>We determine the number of cores we’ll use. In this example, I use four cores.</p>
<pre class="r"><code># Determine cores
# Number of cores in your computer
n_cores &lt;- detectCores()

# It&#39;s recommended to always leave at least one core free
# clust &lt;- makeCluster(n_cores - 1)

# I decided to make an example using 4 cores.
clust &lt;- makeCluster(4)</code></pre>
<p>We have to list the ports that are going to be used to start Selenium.</p>
<pre class="r"><code># List ports
ports = list(4567L, 4444L, 4445L, 5555L)</code></pre>
<p>We use <code>clusterApply()</code> to start Selenium on each core. Pay attention to the use of the Superassignment operator. When you run this function, you will see that four chrome windows are opened.</p>
<pre class="r"><code># Open Selenium on each core, using one port per core. 
clusterApply(clust, ports, function(x){
  library(tidyverse)
  library(RSelenium)
  library(rvest)
  
  # Pay attention to the use of the Superassignment operator.
  rD &lt;&lt;- RSelenium::rsDriver(
    browser = &quot;chrome&quot;,
    chromever = system2(
      command = &quot;wmic&quot;,
      args = &#39;datafile where name=&quot;C:\\\\Program Files (x86)\\\\Google\\\\Chrome\\\\Application\\\\chrome.exe&quot; get Version /value&#39;,
      stdout = TRUE,
      stderr = TRUE) %&gt;%
      stringr::str_extract(pattern = &quot;(?&lt;=Version=)\\d+\\.\\d+\\.\\d+\\.&quot;) %&gt;%
      magrittr::extract(!is.na(.)) %&gt;%
      stringr::str_replace_all(pattern = &quot;\\.&quot;, replacement = &quot;\\\\.&quot;) %&gt;%
      paste0(&quot;^&quot;,  .) %&gt;%
      stringr::str_subset(string = binman::list_versions(appname = &quot;chromedriver&quot;) %&gt;%
                            dplyr::last()) %&gt;%
      as.numeric_version() %&gt;%
      max() %&gt;%
      as.character(),
    port = x
    )
  
  # Pay attention to the use of the Superassignment operator.
  remDr &lt;&lt;- rD[[&quot;client&quot;]]
})</code></pre>
<p>This is an example of pages that we will open in parallel. This list will change depending on the particular scenario.</p>
<pre class="r"><code># List element to iterate with parallel processing
pgs &lt;- list(&quot;https://www.google.com&quot;,
            &quot;https://www.nytimes.com&quot;,
            &quot;https://www.ft.com&quot;)</code></pre>
<p>Use <code>parLapply()</code> to work in parallel. When you run this, you will see that one website was accessed by one browser, and one is still blank. This is a simple example, I haven’t defined any scraping, but of course you can!</p>
<pre class="r"><code># Define iteration
parLapply(clust, pgs, function(x) {
  remDr$navigate(x)
})</code></pre>
<p>when you are done, stop Selenium on each core and stop the cluster.</p>
<pre class="r"><code># Close Selenium on each core
close_rselenium()

# Stop the cluster
stopCluster(clust)</code></pre>
<p><strong>Observation</strong>: Sometimes, when working in parallel some of the browsers close for no apparent reason (or at least a reason that I don’t understand).</p>
</div>
<div id="comments" class="section level1">
<h1>Comments</h1>
<p>Consider the following scenario: your loop navigates to a certain website, clicks some elements and then gets the page source to scrape using <code>rvest</code>. If in the middle of that loop the browser closes, you will get an error (for example, it won’t navigate to the website, or the element won’t be found). You can work around these errors using <code>tryCatch()</code>, but when you skip the iteration where the error occurred, when you try to navigate to the website in the following iteration, an error would occur again (because there is no browser open!).</p>
<p>You could, for example, use <code>remDr$open()</code> in the beggining of the loop, and <code>remDr$close()</code> in the end, but I think that will open and close many browsers and make the process slower.</p>
<p>So I created this function that handles part of the problem (even though the iteration where the browser closed will not finish, the next one will and the process won’t stop).</p>
<p>It basically tries to get the current URL using <code>remDr$getCurrentUrl()</code>. If no browser is open, this will throw an error, and if we get an error, it will open a browser.</p>
<pre class="r"><code>check_chrome &lt;- function(){
  check &lt;- try(suppressMessages(remDr$getCurrentUrl()), silent = TRUE)
  if (&quot;try-error&quot; %in% class(check)) remDr$open(silent = TRUE)
}</code></pre>
</div>
<div id="resources" class="section level1">
<h1>Resources</h1>
<p>The following list contains different videos, posts and StackOverflow posts that I found useful when learning and working with RSelenium.</p>
<ul>
<li><p><strong>The ultimate online collection toolbox: Combining RSelenium and Rvest</strong> ( <a href="https://www.youtube.com/watch?v=OxbvFiYxEzI&amp;t">Part I</a> and <a href="https://www.youtube.com/watch?v=JcIeWiljQG4">Part II</a> ). If you know about <code>rvest</code> and just want to learn about <code>RSelenium</code>, I’d recommend watching Part II. It gives an overview of what you can do when combining <code>RSelenium</code> and <code>rvest</code>. It has nice an practical examples. As a final comment regarding these videos, I would’t pay too much attention to setting up Docker because at least I didn’t need to work that way in order to get <code>RSelenium</code> going. In fact, at least now, getting it going is pretty straightforward.</p></li>
<li><p><a href="http://thatdatatho.com/2019/01/22/tutorial-web-scraping-rselenium/">RSelenium Tutorial: A Tutorial to Basic Web Scraping With RSelenium</a>. I found this post really useful when trying to set up <code>RSelenium</code>. The solution given in <a href="https://stackoverflow.com/questions/55201226/session-not-created-this-version-of-chromedriver-only-supports-chrome-version-7/56173984#56173984">this</a> StackOverflow post, which is mentioned in the article, seems to be enough.</p></li>
<li><p><a href="http://joshuamccrain.com/tutorials/web_scraping_R_selenium.html">RSelenium Tutorial</a>. This post might be helpful too.</p></li>
<li><p><a href="https://docs.ropensci.org/RSelenium/">RSelenium Package Website</a>. It has more advanced and detailed content. I just took a look to the <a href="https://docs.ropensci.org/RSelenium/articles/basics.html">Basics</a> Vignette.</p></li>
<li><p>These StackOverflow posts helped me when <strong>working with dropdown lists</strong>:</p>
<ul>
<li><a href="https://stackoverflow.com/questions/39949809/rselenium-how-to-scrape-all-drop-down-list-option-values">Rselenium - How to scrape all drop down list option values</a></li>
<li><a href="https://stackoverflow.com/questions/26963927/dropdown-boxes-in-rselenium">dropdown boxes in RSelenium</a></li>
</ul></li>
<li><p><a href="https://stackoverflow.com/questions/43991498/rselenium-server-signals-port-is-already-in-use">RSelenium: server signals port is already in use</a>. This post gives a solution to the “port already in use” problem. Even though is not marked as best, the last line of code of the second answer is useful.</p></li>
<li><p><a href="https://stackoverflow.com/questions/50310595/data-scraping-in-r">Data Scraping in R</a>. Thanks to this post I found the <a href="https://www.premierleague.com/stats/top/players/goals">Premier League Stats</a> website, which was exactly was I was looking for to write a post about <code>RSelenium</code>. Also, I took some hints from the answer marked as best.</p></li>
</ul>
</div>
